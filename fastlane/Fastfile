require 'fastlane/actions/scan'

# Examples of how to use the various actions provided by the test_control
# fastlane plugin
#
# Simply type `bundle exec fastlane test` from the command line to see everything
# in action. To run just one "lane", type `bundle exec fastlane <lanename>` from
# the command line, where <lanename> the name of the `lane`. For example, to
# watch the `:junit_tests` lane in action, type, `bundle exec fastlane junit_tests`

lane :test do
  suppress_all
  suppress_one
  suppressed_for_all
  suppressed_for_one
  suppressed_junits_for_all
  junit_tests
  test_multiscan_two_testables_failing
  test_multiscan_two_testables
  test_multiscan_one_testable
  test_multiscan_batch_callback
  xctestrun_tests
end

after_each do |lane, options|
  `git checkout -- ..`
end

### the individual lanes

lane :suppress_all do
  # suppress some tests in the project
  suppress_tests(
    xcodeproj: 'AtomicBoy/AtomicBoy.xcodeproj',
    tests: [
      'AtomicBoyUITests/HappyNapperTests/testBeepingNonExistentFriendDisplaysError',
      'AtomicBoyUITests/GrumpyWorkerTests'
    ]
  )
end

lane :suppress_one do
  # suppress some tests in one scheme in the project
  suppress_tests(
    xcodeproj: 'AtomicBoy/AtomicBoy.xcodeproj',
    tests: [
      'AtomicBoyUITests/HappyNapperTests/testBeepingNonExistentFriendDisplaysError',
      'AtomicBoyUITests/GrumpyWorkerTests'
    ],
    scheme: 'Professor'
  )
end

lane :suppressed_for_all do
  # get all the tests suppressed in the project
  UI.message(
    "Suppressed tests for project: #{suppressed_tests(xcodeproj: 'AtomicBoy/AtomicBoy.xcodeproj')}"
  )
end

lane :suppressed_for_one do
  # get the suppressed tests in one scheme in the project
  tests = suppressed_tests(
    xcodeproj: 'AtomicBoy/AtomicBoy.xcodeproj',
    scheme: 'AtomicBoy'
  )
  UI.message("Suppressed tests for scheme: #{tests}")
end

lane :suppressed_junits_for_all do
  # use the junit test report file to suppress the failed tests in the project
  suppress_tests_from_junit(
    xcodeproj: 'AtomicBoy/AtomicBoy.xcodeproj',
    junit: './spec/fixtures/junit.xml',
    suppress_type: :failed
  )
  UI.message(
    "Suppressed tests for project: #{suppressed_tests(xcodeproj: 'AtomicBoy/AtomicBoy.xcodeproj')}"
  )
end

lane :junit_tests do
  # get the failed and passing tests from the junit test report file
  result = tests_from_junit(junit: './spec/fixtures/junit.xml')
  UI.message("Passing tests: #{result[:passing]}")
  UI.message("Failed tests: #{result[:failed]}")
end

lane :test_multiscan_two_testables do
  # run tests for a scheme that has two test targets, re-trying up to 2 times if
  # tests fail. Turn off the default behavior of failing the build if, at the
  # end of the action, there were 1 or more failing tests.
  summary = multi_scan(
    project: File.absolute_path('../AtomicBoy/AtomicBoy.xcodeproj'),
    scheme: 'AtomicBoy',
    try_count: 3,
    fail_build: false
  )
  UI.success("multi_scan passed? #{summary[:result]}")
end

lane :test_multiscan_two_testables_failing do
  # run tests for a scheme that has two test targets, re-trying up to 2 times if
  # tests fail. Make sure that the default behavior of failing the build works.
  begin
    multi_scan(
      project: File.absolute_path('../AtomicBoy/AtomicBoy.xcodeproj'),
      scheme: 'AtomicBoy',
      try_count: 1
    )
  rescue FastlaneCore::Interface::FastlaneTestFailure => e
    UI.success("failed successfully with #{e.message}")
  else
    raise 'This should have failed'
  end
end

lane :test_multiscan_one_testable do
  # make sure that running tests for a scheme that has one test target still
  # works.
  multi_scan(
    project: File.absolute_path('../AtomicBoy/AtomicBoy.xcodeproj'),
    scheme: 'Professor',
    try_count: 3,
    custom_report_file_name: 'atomic_report.xml',
    output_types: 'junit',
    fail_build: false
  )
end

lane :test_multiscan_batch do
  # re-try batches of tests in the project
  multi_scan(
    project: File.absolute_path('../AtomicBoy/AtomicBoy.xcodeproj'),
    scheme: 'AtomicBoy',
    try_count: 3,
    batch_count: 2
  )
end

lane :test_multiscan_batch_callback do
  # provide better control over your tests with the :testrun_completed_block
  # callback
  multi_scan(
    project: File.absolute_path('../AtomicBoy/AtomicBoy.xcodeproj'),
    scheme: 'AtomicBoy',
    try_count: 3,
    batch_count: 2,
    testrun_completed_block: lambda { |testrun_info|
      failed_test_count = testrun_info[:failed].size
      passed_test_count = testrun_info[:passing].size
      try_attempt = testrun_info[:try_count]
      batch = testrun_info[:batch]

      if passed_test_count > 0 && failed_test_count > passed_test_count / 2
        UI.abort_with_message!("Too many tests are failing")
      end
      UI.message("ðŸ˜Š everything is fine, let\'s continue try #{try_attempt + 1} for batch #{batch}")
    }
  )
end

lane :test_multiscan_workspace do
  # use the workspace parameter instead of the project param
  multi_scan(
    workspace: File.absolute_path('../AtomicBoy/AtomicBoy.xcworkspace'),
    scheme: 'AtomicBoy',
    try_count: 3
  )
end

lane :xctestrun_tests do
  # get the tests from an xctestrun file
  scan(
    build_for_testing: true,
    workspace: File.absolute_path('../AtomicBoy/AtomicBoy.xcworkspace'),
    scheme: 'AtomicBoy'
  )

  derived_data_path = Scan.config[:derived_data_path]
  xctestrun_file = Dir.glob("#{derived_data_path}/Build/Products/*.xctestrun").first
  tests = tests_from_xctestrun(xctestrun: xctestrun_file)
  tests.values.flatten.each { |test_identifier| puts test_identifier }
end

